<!DOCTYPE html>
<html>
<head>
</head>
<body style="font-family: Verdana;font-size: 12pt;color: #494c4e;">
<h1>CECS 323 Project 3:<br>Feature Complete</h1>
<p>Due date:</p>
<ul>
<li>Section 2:&nbsp;</li>
<li>Section 4:&nbsp;</li>
<li>Section 6:&nbsp;</li>
</ul>
<p>You may work on and submit this project with one other person.</p>
<h2>Overview</h2>
<p>In this project, you will implement a JPA code-first application for the "canonical solution" to Project 2. You will not use DataGrip to design tables; instead, you will write Java classes and use JPA annotations to set columns, keys, and associations, then let JPA generate the database schema automatically. After implementing the classes, you will write a short application to fill in the database with specific object instances, and then write a demo application where a user gets to see details on automobiles in the database.</p>
<h2>The Enterprise</h2>
<p>The enterprise for this project is an excerpt from the&nbsp;<strong>UML</strong> design of the Project 2 Canonical Solution. Specifically, we will ignore/delete the Color, BodyStyle, and Manufacturer classes; you do not need to incorporate these fields in other places, e.g., you do <strong>not</strong> have to add a "color" field to the Automobile class -- simply assume that Color is no longer part of the enterprise. The remaining&nbsp;<strong>six classes</strong> -- Model, Trim, Package, Feature, AvailablePackage, and Automobile -- form the requirements for this project.</p>
<h2>Modeling the Enterprise in JPA</h2>
<p>You are tasked with modeling the above enterprise as JPA entity classes,&nbsp;<em>without</em> creating those entities as tables by yourself. (I repeat: <strong>do not create tables in DataGrip</strong>.)&nbsp;Each class in the diagram must be implemented as a Java class, using JPA annotations to set columns, keys, and associations. Specifically, your classes must:</p>
<ul>
<li>Include all fields from the UML design, using appropriate Java data types.
<ul>
<li>For string types, choose a reasonable maximum length for the field, and use @Length as an annotation.</li>
<li>You do not need to use @Column(name = ...) to rename fields from Java's naming rules to the rules we preferred earlier in the course. In general, you do not need to match the column and table names I used in the relation scheme for Project 2 Canonical Solution. You can reference them, but you do not need to match exactly.</li>
<li>You&nbsp;<strong>do</strong> need to use @Column(nullable = false) to indicate columns that cannot be null. (This is not necessary for primary keys, which can never be null.)</li>
</ul>
</li>
<li>Introduce surrogate keys for each class that is the parent of a one-to-many or involved in a many-to-many. In this design, that's <em>every single class.</em>
<ul>
<li>Your surrogate keys should be 4-byte integer values.</li>
<li>You must use @GeneratedValue(strategy = GenerationType.IDENTITY) annotations for your surrogate key fields, which will create Postgres tables with "serial" columns.</li>
</ul>
</li>
<li>Set the class primary key(s) using @Id.</li>
<li><strong>Not include foreign key columns as fields</strong>, e.g., the Automobile class should not have a "trimId" integer field. Instead, all associations <strong>must be modeled as JPA associations</strong>&nbsp;as shown in lecture.<br>
<ul>
<li>This means using @OneToOne, @OneToMany, @ManyToOne, @ManyToMany, @JoinColumn, and @JoinTable correctly.</li>
<li>These associations should be&nbsp;<strong>unidirectional</strong>&nbsp;in the order specified:
<ul>
<li>Package -&gt; Feature (example: a Package can tell you its set of Features, but a single Feature cannot tell you which Packages it comes from)</li>
<li>Trim -&gt; Feature</li>
<li>Model -&gt; Feature</li>
<li>Automobile -&gt; Trim</li>
</ul>
</li>
<li>These associations should be&nbsp;<strong>bidirectional</strong>:<br>
<ul>
<li>Trim - Model</li>
<li>Trim - Package</li>
<li>Automobile - AvailablePackage</li>
</ul>
</li>
</ul>
</li>
<li>Set up any&nbsp;<strong>unique keys</strong>&nbsp;in the class:
<ul>
<li>Automobile: unique vin.</li>
<li>Trim: unique (modelId, name).</li>
<li>Feature: unique (name)</li>
<li>Model: unique (name, year)</li>
<li>You will need to Google how to do a multi-column unique constraint in JPA. It uses an annotation on the class itself.</li>
</ul>
</li>
<li><strong>Using your IDE</strong>&nbsp;(please god don't do this by hand), generate code for:
<ul>
<li>a parameter-less constructor</li>
<li>a constructor taking all&nbsp;<strong>mandatory</strong>&nbsp;fields
<ul>
<li>A mandatory field is one that the programmer&nbsp;<strong>must</strong>&nbsp;provide for the object to have a meaningful state.&nbsp;</li>
<li>Generated fields are not mandatory; they will be generated by JPA. Even if you attempt to set your own "trimId", it will be overridden by JPA if it has the @GeneratedValue annotation.</li>
<li>Associations (references to other objects) are only mandatory if they can &amp; must be known at object construction, and not knowing them would leave the object in an invalid state. A Trim must know its Model at construction; but it might not know its entire set of AvailablePackages (especially because that might change over time), so the Trim constructor should not mandate a collection of AvailablePackages.</li>
<li>Any collection that is not mandatory should be initialized as empty in the constructor;&nbsp;<strong>not</strong>&nbsp;left to be null. (Another programmer should&nbsp;<strong>not</strong>&nbsp;have to check your "getX()" method to see if that's null prior to trying to add something to it.)</li>
</ul>
</li>
<li>getters for all fields</li>
<li>setters for all non-primary key fields.
<ul>
<li>Once an object is persisted to the database, its primary key cannot change (you cannot UPDATE a primary key column). So there should not be public setters for PK fields.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Dealing with mistakes</h3>
<p>Since we are using JPA to generate our tables, running our program before our work is complete will result in an incomplete database being created. This is a good and bad thing. It lets us inspect the tables created by JPA using DataGrip to make sure they look how we intend so far, but the JPA demo I gave you&nbsp;<strong>won't create tables if the tables already exist</strong>. This is normally what you want; you don't want all your data to be erased each time you run an application. But while you're doing development work, this can get annoying; if you make a mistake in a table, run the app, fix the mistake, and run the app again, the app&nbsp;<strong>won't</strong>&nbsp;update your table because the table already exists.</p>
<p>I recommend editing the&nbsp;<strong>src/META-INF/persistence.xml</strong> file in your application to change this. You want the entry for "jakarta.persistence.schema-generation.database.action"; uncomment the line to go to "drop-and-create" mode.&nbsp;</p>
<blockquote></blockquote>
<p>Once you're satisfied that your classes are correct, you can change this setting back to&nbsp;<strong>create</strong>&nbsp;so that you won't lose any objects that you add to the database when you are testing the application code. (More on this below.)</p>
<h3>Adding application logic</h3>
<p>Until this point, your classes are only for modeling the data; they have no real&nbsp;<em>behaviors</em> / methods other than boilerplate getters and setters, and the bidirectional helper methods. You will add <strong>two</strong> "application" logic methods to your class Automobile:</p>
<ol>
<li>public Set&lt;Feature&gt; getFeatures()<br>Returns a Set of all Feature objects that this Automobile has because of its Model, Trim, or chosen Packages. The HashSet class and its addAll method will be helpful here.&nbsp;</li>
<li>public double stickerPrice()<br>Returns the "sticker price" of the automobile: the sum of the Trim cost, plus the costs of all packages added to the automobile. Do not try to write a JPQL query to do this; you have all the data you need among the fields of the Automobile object and the methods of its related classes.</li>
</ol>
<h2>Instantiating the Model</h2>
<p>Once your model classes are correct and JPA seems to be generating the correct database schema, you can move on to writing a Java method to instantiate the model by creating Java objects and persisting them to an EntityManager, in order to give the database some "default" values to work with.</p>
<p>Your method should create the following objects, using public methods of your entity classes to add associations between related objects:</p>
<ul>
<li>Features:
<ul>
<li>leather seats</li>
<li>plug-in hybrid engine</li>
<li>power sliding doors</li>
<li>hands-free sliding doors</li>
<li>Amazon FireTV</li>
<li>rear-seat entertainment screens</li>
<li>all-wheel drive</li>
<li>adaptive cruise control</li>
</ul>
</li>
<li>Packages:
<ul>
<li>Theater Package
<ul>
<li>Features: rear-seat entertainment screens</li>
</ul>
</li>
<li>Amazon Theater Package
<ul>
<li>Features: rear-seat entertainment screens; Amazon FireTV</li>
</ul>
</li>
<li>Safety Package<br>
<ul>
<li>Features: adaptive cruise control</li>
</ul>
</li>
</ul>
</li>
<li>Models:
<ul>
<li>Pacifica, 2022
<ul>
<li>Features: power sliding doors</li>
<li>Trims:
<ul>
<li>Touring ($30,000).
<ul>
<li>Compatible packages: Safety Package ($3000)</li>
</ul>
</li>
<li>Limited ($34,000).
<ul>
<li>Features: leather seats, hands-free sliding doors.</li>
<li>Compatible packages: Amazon Theater Package ($2500)</li>
</ul>
</li>
<li>Pinnacle($42,000).
<ul>
<li>Features: leather seats, hands-free sliding doors, rear-seat entertainment screens, Amazon FireTV, all-wheel drive.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Pacifica Hybrid, 2022
<ul>
<li>Features: power sliding doors, plug-in hybrid engine&nbsp;</li>
<li>Trims:
<ul>
<li>Touring ($43,000).</li>
<li>Limited ($48,000).
<ul>
<li>Features: leather seats, hands-free sliding doors.</li>
<li>Compatible packages: Amazon Theater Package ($2500)</li>
</ul>
</li>
<li>Pinnacle($54,000).
<ul>
<li>Features: leather seats, hands-free sliding doors, rear-seat entertainment screens, Amazon FireTV.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Pacifica Hybrid, 2021
<ul>
<li>Features: power sliding doors, plug-in hybrid engine&nbsp;</li>
<li>Trims:
<ul>
<li>Touring ($41,000).
<ul>
<li>Compatible packages: Safety Package ($3000)</li>
</ul>
</li>
<li>Limited ($46,000).
<ul>
<li>Features: leather seats, hands-free sliding doors.</li>
<li>Compatible packages: Theater Package ($2500), Safety Package ($2000)</li>
</ul>
</li>
<li>Pinnacle($52,000).
<ul>
<li>Features: leather seats, hands-free sliding doors, rear-seat entertainment screens, adaptive cruise control.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Automobiles:
<ul>
<li>VIN 12345abcde, 2022 Pacifica, Limited trim. Amazon Theater Package.</li>
<li>VIN 67890abcde, 2022 Pacifica Hybrid, Pinnacle trim. No packages chosen.</li>
<li>VIN 99999aaaaa, 2021 Pacifica Hybrid, Pinnacle trim. No packages chosen.</li>
<li>VIN aaaaa88888, 2021 Pacifica Hybrid, Touring trim. Safety Package.</li>
<li>VIN bbbbb77777, 2021 Pacifica Hybrid, Limited trim. Safety Package, Theater Package.&nbsp;</li>
</ul>
</li>
</ul>
<h2>Programming the Registration Application</h2>
<p>Once your model instantiation is done and tested, you can write the actual application for this project. Your main will print a menu with three options, then branch on the user's choice. Each branch should be its own method called by the main.</p>
<p>Options:</p>
<ol>
<li>Instantiate model.&nbsp;
<ul>
<li>Instantiates the model using the code you previously wrote.</li>
</ul>
</li>
<li>Automobile lookup.
<ol>
<li>User enters the VIN of an automobile.</li>
<li>Use JPQL to find that automobile if it exists.</li>
<li>If it does, print the automobile's information in the following format:<br>[year] [model] [trim]<br>[sticker price]<br>Features:<br>[all of the automobile's features, in alphabetical order, one per line]</li>
<li><strong>WARNING</strong>: this branch requires running a query with user input. You&nbsp;<strong>must</strong> correctly used a parameterized query to eliminate potential injection attacks. Doing this incorrectly will net a&nbsp;<strong>20% deduction on your project.&nbsp;</strong>(Yes, I am serious.)</li>
</ol>
</li>
<li>Feature search.
<ol>
<li>User enters the name of a Feature.&nbsp;</li>
<li>Use JPQL to find the Feature if it exists.</li>
<li>If it does, print the VIN of every Automobile with that Feature.<br>This is tricky, because our Feature class does not have a bidirectional reference to the Trim, Model, or Package objects that include that feature.&nbsp;<strong>This is deliberate, and you cannot add bidirectional references to solve this problem</strong>. You need to find a different way.<br><br>You must do this efficiently, which means you&nbsp;<strong>cannot</strong> select all Automobile objects and then ask each individually if it has the given feature. The correct way will be to use JPQL JOINs to navigate an automobile's relationships in JPQL. JOIN is a little different than in SQL; the JPQL query below will find any Automobile whose Trim has a feature named 'leather seats', and you should be able to extrapolate the rest from here.<br><br>SELECT a<br>FROM automobiles a<br>JOIN a.trim t<br>JOIN t.features tf<br>WHERE tf.name = 'leather seats'<br><br></li>
<li>See the note above about injection attacks.</li>
</ol>
</li>
</ol>
<h2>Deliverables</h2>
<p>You must deliver:</p>
<ul>
<li>The&nbsp;<strong>src/</strong>&nbsp;folder and all its contents&nbsp;<strong>only</strong>. Do not turn in the lib/, out/, prod/ etc. folders.&nbsp;</li>
</ul>
</body>
</html>